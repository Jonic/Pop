(function() {
  var AnimationLoop, Config, Game, Input, Particle, ParticleGenerator, PlayState, Scenes, UI, Utils, android, animationLoop, backingStoreRatio, body, canvas, config, context, debug, devicePixelRatio, game, hasTouchEvents, input, inputVerb, oldHeight, oldWidth, particleGenerator, playState, ratio, scenes, ui, utils;

  AnimationLoop = (function() {
    function AnimationLoop() {}

    AnimationLoop.prototype.init = function() {
      this.requestAnimationFrame();
      this.animationLoopId;
      return this;
    };

    AnimationLoop.prototype.cancelAnimationFrame = function() {
      window.cancelAnimationFrame(this.animationLoopId);
      return this;
    };

    AnimationLoop.prototype.requestAnimationFrame = function() {
      var self;
      self = this;
      this.animationLoopId = window.requestAnimationFrame(function() {
        self.requestAnimationFrame();
      });
      canvas.width = canvas.width;
      particleGenerator.animationLoopActions();
      return this;
    };

    return AnimationLoop;

  })();

  Config = (function() {
    function Config() {}

    Config.prototype.init = function() {
      var baseParticleWidth, baseScreenWidth;
      this.particleWidthAsPercentageOfScreen = 15;
      baseScreenWidth = Math.min(document.body.clientWidth, document.body.clientHeight);
      baseParticleWidth = Math.round((baseScreenWidth / 100) * this.particleWidthAsPercentageOfScreen);
      this.baseParticleSize = baseParticleWidth * devicePixelRatio;
      this.maxLineWidth = 5;
      this.levelUpInterval = 5;
      this.maxLevel = 50;
      this.pointsPerPop = 10;
      this.chanceParticleIsTarget = {
        easy: 50,
        difficult: 90
      };
      this.maxTargetsAtOnce = {
        easy: 3,
        difficult: 6
      };
      this.minTargetSize = {
        easy: this.baseParticleSize * 0.7,
        difficult: this.baseParticleSize * 0.4
      };
      this.particleGrowthMultiplier = {
        easy: 1.05,
        difficult: 1.10
      };
      this.particleSpawnChance = {
        easy: 60,
        difficult: 100
      };
      this.sizeMax = {
        easy: this.baseParticleSize,
        difficult: this.baseParticleSize * 0.6
      };
      this.targetVelocityMultiplier = {
        easy: 0.3,
        difficult: 0.5
      };
      this.velocityMin = {
        easy: -6,
        difficult: -10
      };
      this.velocityMax = {
        easy: 6,
        difficult: 10
      };
      this.propertiesToUpdateWithDifficulty = ['particleSpawnChance', 'chanceParticleIsTarget', 'particleGrowthMultiplier', 'sizeMax', 'maxTargetsAtOnce', 'minTargetSize', 'velocityMin', 'velocityMax', 'targetVelocityMultiplier'];
      return this;
    };

    Config.prototype.updateValuesForDifficulty = function() {
      var levelMulitplier, property, propertyConfig, valueDifference, _i, _len, _ref;
      _ref = this.propertiesToUpdateWithDifficulty;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        propertyConfig = this[property];
        valueDifference = propertyConfig.difficult - propertyConfig.easy;
        levelMulitplier = playState.level / this.maxLevel;
        playState[property] = (valueDifference * levelMulitplier) + propertyConfig.easy;
      }
      return this;
    };

    return Config;

  })();

  Game = (function() {
    function Game() {}

    Game.prototype.init = function() {
      config.init();
      particleGenerator.init();
      playState.init();
      ui.init();
      input.init();
      animationLoop.init();
      scenes.ident();
      return this;
    };

    Game.prototype.over = function() {
      scenes.gameOver();
      playState.stopLevelUpIncrement();
      return this;
    };

    Game.prototype.start = function() {
      playState.setToInitialState();
      ui.setToInitialState();
      input.removeGameStartTapEventHandler();
      particleGenerator.setToInitialState();
      scenes.playing();
      return this;
    };

    return Game;

  })();

  Input = (function() {
    function Input() {}

    Input.prototype.init = function() {
      this.cancelTouchMoveEvents();
      return this;
    };

    Input.prototype.addGameStartTapEventHandler = function() {
      body.addEventListener(inputVerb, this.gameStartTapEventHandler);
      return this;
    };

    Input.prototype.cancelTouchMoveEvents = function() {
      window.addEventListener('touchmove', function(event) {
        event.preventDefault();
      });
      return this;
    };

    Input.prototype.gameStartTapEventHandler = function(event) {
      event.preventDefault();
      game.start();
      return this;
    };

    Input.prototype.getTapCoordinates = function(event) {
      var tapCoordinates;
      if (hasTouchEvents) {
        tapCoordinates = event.touches[0];
      } else {
        tapCoordinates = {
          pageX: event.clientX,
          pageY: event.clientY
        };
      }
      return tapCoordinates;
    };

    Input.prototype.particleWasTapped = function(particle, touchData) {
      var distanceX, distanceY, radius, tapX, tapY;
      tapX = touchData.pageX * devicePixelRatio;
      tapY = touchData.pageY * devicePixelRatio;
      distanceX = tapX - particle.position.x;
      distanceY = tapY - particle.position.y;
      radius = particle.half;
      return (distanceX * distanceX) + (distanceY * distanceY) < (particle.half * particle.half);
    };

    Input.prototype.particleTapDetectionHandler = function(event) {
      var deletionIndex, particle, particleId, particleIndex, targetHit, touchData, _i, _len, _ref;
      targetHit = false;
      _ref = particleGenerator.particlesToTestForTaps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particleId = _ref[_i];
        particleIndex = particleGenerator.particlesArrayIds.indexOf(particleId);
        particle = particleGenerator.particlesArray[particleIndex];
        touchData = this.getTapCoordinates(event);
        if ((particle != null) && this.particleWasTapped(particle, touchData)) {
          deletionIndex = particleGenerator.particlesToTestForTaps.indexOf(particleId);
          particle.destroying = true;
          targetHit = true;
          particleGenerator.particlesToTestForTaps.splice(deletionIndex, 1);
          break;
        }
      }
      playState.updateComboMultiplier(targetHit);
      if (targetHit) {
        playState.updateScore(particle.size, particle.finalSize);
      }
      return this;
    };

    Input.prototype.removeGameStartTapEventHandler = function() {
      document.body.removeEventListener(inputVerb, this.gameStartTapEventHandler);
      return this;
    };

    Input.prototype.setupParticleTapDetection = function() {
      var self;
      self = this;
      particleGenerator.particlesToTestForTaps = [];
      window.addEventListener(inputVerb, function(event) {
        self.particleTapDetectionHandler(event);
      });
      return this;
    };

    return Input;

  })();

  Particle = (function() {
    function Particle() {}

    Particle.prototype.init = function() {
      var colors;
      colors = {
        r: utils.randomInteger(0, 200),
        g: utils.randomInteger(0, 200),
        b: utils.randomInteger(0, 200),
        a: utils.random(0.75, 1)
      };
      this.color = 'rgba(' + colors.r + ', ' + colors.g + ', ' + colors.b + ', ' + colors.a + ')';
      this.destroying = false;
      this.finalSize = utils.randomInteger(0, playState.sizeMax);
      this.id = Math.random().toString(36).substr(2, 5);
      this.isTarget = this.determineTargetParticle();
      this.position = {
        x: particleGenerator.particlesOrigin.x,
        y: particleGenerator.particlesOrigin.y
      };
      this.size = 1;
      this.velocity = {
        x: utils.random(playState.velocityMin, playState.velocityMax),
        y: utils.random(playState.velocityMin, playState.velocityMax)
      };
      if (this.isTarget) {
        this.color = 'rgba(' + colors.r + ', ' + colors.g + ', ' + colors.b + ', 0.8)';
        this.finalSize = utils.randomInteger(playState.minTargetSize, playState.sizeMax);
        this.velocity.x *= playState.targetVelocityMultiplier;
        this.velocity.y *= playState.targetVelocityMultiplier;
      }
      return this;
    };

    Particle.prototype.determineTargetParticle = function() {
      var isTarget;
      isTarget = false;
      if (particleGenerator.particlesToTestForTaps.length < playState.maxTargetsAtOnce) {
        isTarget = utils.randomPercentage() < playState.chanceParticleIsTarget;
      }
      return isTarget;
    };

    Particle.prototype.draw = function() {
      if (this.outsideCanvasBounds()) {
        particleGenerator.particlesToDelete.push(this.id);
        return;
      }
      if (this.isTarget) {
        this.lineWidth = this.size / 10;
        if (this.lineWidth > config.maxLineWidth) {
          this.lineWidth = config.maxLineWidth;
        }
        context.fillStyle = 'rgba(247, 247, 247, 0.9)';
        context.lineWidth = this.lineWidth;
      }
      context.beginPath();
      context.arc(this.position.x, this.position.y, this.half, 0, Math.PI * 2, true);
      context.fill();
      if (this.isTarget) {
        context.stroke();
      }
      context.closePath();
      return this;
    };

    Particle.prototype.outsideCanvasBounds = function() {
      var beyondBoundsX, beyondBoundsY;
      beyondBoundsX = this.position.x < -this.finalSize || this.position.x > canvas.width + this.finalSize;
      beyondBoundsY = this.position.y < -this.finalSize || this.position.y > canvas.height + this.finalSize;
      return beyondBoundsX || beyondBoundsY;
    };

    Particle.prototype.updateValues = function() {
      var shrinkMultiplier;
      if (this.destroying) {
        shrinkMultiplier = playState.playing ? 0.7 : 0.9;
        this.size *= shrinkMultiplier;
      } else {
        if (this.size < this.finalSize) {
          this.size *= playState.particleGrowthMultiplier;
        }
        if (this.size > this.finalSize) {
          this.size = this.finalSize;
        }
      }
      this.half = this.size / 2;
      this.position.x += this.velocity.x;
      this.position.y += this.velocity.y;
      this.draw();
      return this;
    };

    return Particle;

  })();

  ParticleGenerator = (function() {
    function ParticleGenerator() {}

    ParticleGenerator.prototype.init = function() {
      this.particlesOrigin = {
        x: canvas.width / 2,
        y: canvas.height / 2
      };
      this.setToInitialState();
      input.setupParticleTapDetection();
      return this;
    };

    ParticleGenerator.prototype.animationLoopActions = function() {
      if (playState.playing) {
        this.generateParticle();
      }
      this.updateParticlesValues();
      this.removeParticlesAfterTap();
      if (this.particlesToDelete.length > 0) {
        this.destroyParticlesOutsideCanvasBounds();
      }
      return this;
    };

    ParticleGenerator.prototype.destroyParticlesOutsideCanvasBounds = function() {
      var particle, particleId, particleIndex, _i, _len, _ref;
      _ref = this.particlesToDelete;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particleId = _ref[_i];
        particleIndex = this.particlesArrayIds.indexOf(particleId);
        particle = this.particlesArray[particleIndex];
        if (particle != null) {
          if (particle.isTarget) {
            this.gameOver();
          }
          this.removeParticle(particle);
        }
      }
      this.particlesToDelete = [];
      return this;
    };

    ParticleGenerator.prototype.gameOver = function() {
      var particle, _i, _len, _ref;
      this.stop();
      _ref = this.particlesArray;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        particle.destroying = true;
      }
      playState.particleSpawnChance = 0;
      game.over();
      return this;
    };

    ParticleGenerator.prototype.generateParticle = function() {
      var newParticle, particle;
      if (utils.randomPercentage() < playState.particleSpawnChance) {
        newParticle = new Particle();
        particle = newParticle.init();
        this.particlesArray.push(particle);
        this.particlesArrayIds.push(particle.id);
        if (particle.isTarget) {
          this.particlesToTestForTaps.unshift(particle.id);
        }
      }
      return this;
    };

    ParticleGenerator.prototype.removeParticle = function(particle) {
      var id, index;
      id = particle.id;
      index = this.particlesArrayIds.indexOf(id);
      this.particlesArray.splice(index, 1);
      this.particlesArrayIds.splice(index, 1);
      return this;
    };

    ParticleGenerator.prototype.removeParticlesAfterTap = function() {
      var particle, _i, _len, _ref;
      _ref = this.particlesArray;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        if ((particle != null) && particle.size < 1) {
          this.removeParticle(particle);
        }
      }
      return this;
    };

    ParticleGenerator.prototype.setToInitialState = function() {
      this.particlesArray = [];
      this.particlesArrayIds = [];
      this.particlesToDelete = [];
      this.particlesToTestForTaps = [];
      return this;
    };

    ParticleGenerator.prototype.stop = function() {
      playState.update(false);
      playState.stopLevelUpIncrement();
      return this;
    };

    ParticleGenerator.prototype.updateParticlesValues = function() {
      var particle, _i, _len, _ref;
      _ref = this.particlesArray;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        if (particle != null) {
          context.fillStyle = particle.color;
          context.strokeStyle = particle.color;
          particle.updateValues();
        }
      }
      return this;
    };

    return ParticleGenerator;

  })();

  PlayState = (function() {
    function PlayState() {}

    PlayState.prototype.init = function() {
      this.defaults = {
        level: 1,
        score: 0,
        comboMultiplier: 0
      };
      return this;
    };

    PlayState.prototype.stopLevelUpIncrement = function() {
      window.clearInterval(this.levelUpCounter);
      return this;
    };

    PlayState.prototype.setupLevelUpIncrement = function() {
      var self;
      self = this;
      this.levelUpCounter = window.setInterval(function() {
        self.updateLevel();
      }, config.levelUpInterval * 1000);
      return this;
    };

    PlayState.prototype.setToInitialState = function() {
      this.level = this.defaults.level;
      this.chanceParticleIsTarget = config.chanceParticleIsTarget.easy;
      this.comboMultiplier = this.defaults.comboMultiplier;
      this.maxTargetsAtOnce = config.maxTargetsAtOnce.easy;
      this.minTargetSize = config.minTargetSize.easy;
      this.particleGrowthMultiplier = config.particleGrowthMultiplier.easy;
      this.particleSpawnChance = config.particleSpawnChance.easy;
      this.score = this.defaults.score;
      this.sizeMax = config.sizeMax.easy;
      this.targetVelocityMultiplier = config.targetVelocityMultiplier.easy;
      this.velocityMin = config.velocityMin.easy;
      this.velocityMax = config.velocityMax.easy;
      this.update(true);
      config.updateValuesForDifficulty();
      this.setupLevelUpIncrement();
      return this;
    };

    PlayState.prototype.updateComboMultiplier = function(targetHit) {
      this.comboMultiplier = targetHit ? this.comboMultiplier + 1 : this.defaults.comboMultiplier;
      ui.updateComboMultiplierCounter();
      return this;
    };

    PlayState.prototype.update = function(newState) {
      this.playing = newState;
      return this;
    };

    PlayState.prototype.updateLevel = function() {
      this.level += 1;
      if (this.level >= config.maxLevel) {
        window.clearInterval(this.levelUpCounter);
      }
      ui.updateLevelCounter();
      config.updateValuesForDifficulty();
      return this;
    };

    PlayState.prototype.updateScore = function(sizeWhenTapped, sizeWhenFullyGrown) {
      var levelMultiplier, popPointValue, targetSizeBonus;
      targetSizeBonus = Math.round(100 - ((sizeWhenTapped / sizeWhenFullyGrown) * 100));
      popPointValue = config.pointsPerPop + targetSizeBonus;
      levelMultiplier = this.level + 1;
      this.score += (popPointValue * this.comboMultiplier) * levelMultiplier;
      ui.updateScoreCounter();
      return this;
    };

    return PlayState;

  })();

  Scenes = (function() {
    function Scenes() {}

    Scenes.prototype.credits = function() {
      ui.updateBodyClass('credits');
      return this;
    };

    Scenes.prototype.gameOver = function() {
      ui.updateBodyClass('game-over');
      input.addGameStartTapEventHandler();
      return this;
    };

    Scenes.prototype.leaderboard = function() {
      return this;
    };

    Scenes.prototype.playing = function() {
      ui.updateBodyClass('playing');
      return this;
    };

    Scenes.prototype.ident = function() {
      var self;
      self = this;
      ui.updateBodyClass('ident');
      window.setTimeout(function() {
        return self.title();
      }, 5000);
      return this;
    };

    Scenes.prototype.title = function() {
      ui.updateBodyClass('title');
      input.addGameStartTapEventHandler();
      return this;
    };

    return Scenes;

  })();

  UI = (function() {
    function UI() {}

    UI.prototype.init = function() {
      this.body = document.body;
      this.levelCounter = utils.$('.hud-value-level');
      this.scoreCounter = utils.$('.hud-value-score');
      this.comboMultiplierCounter = utils.$('.hud-value-combo');
      this.playAgain = utils.$('.play-again');
      return this;
    };

    UI.prototype.updateBodyClass = function(className) {
      this.body.className = '';
      this.body.classList.add('scene-' + className);
      return this;
    };

    UI.prototype.setToInitialState = function() {
      this.updateComboMultiplierCounter();
      this.updateLevelCounter();
      this.updateScoreCounter();
      return this;
    };

    UI.prototype.updateComboMultiplierCounter = function() {
      utils.updateUITextNode(this.comboMultiplierCounter, playState.comboMultiplier);
      return this;
    };

    UI.prototype.updateLevelCounter = function() {
      utils.updateUITextNode(this.levelCounter, playState.level);
      return this;
    };

    UI.prototype.updateScoreCounter = function() {
      var scoreToFormat;
      scoreToFormat = utils.formatWithComma(playState.score);
      utils.updateUITextNode(this.scoreCounter, scoreToFormat);
      return this;
    };

    return UI;

  })();

  Utils = (function() {
    function Utils() {}

    Utils.prototype.$ = function(selector) {
      var els;
      if (selector.substr(0, 1) === '#') {
        return document.getElementById(selector);
      }
      els = document.querySelectorAll(selector);
      if (els.length === 1) {
        return els[0];
      }
      return els;
    };

    Utils.prototype.correctValueForDPR = function(value, integer) {
      if (integer == null) {
        integer = false;
      }
      value *= devicePixelRatio;
      if (integer) {
        value = Math.round(value);
      }
      return value;
    };

    Utils.prototype.formatWithComma = function(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };

    Utils.prototype.random = function(min, max) {
      if (min === void 0) {
        min = 0;
        max = 1;
      } else if (max === void 0) {
        max = min;
        min = 0;
      }
      return (Math.random() * (max - min)) + min;
    };

    Utils.prototype.randomColor = function(alpha) {
      var colors;
      if (alpha == null) {
        alpha = false;
      }
      colors = {
        r: this.randomInteger(0, 200),
        g: this.randomInteger(0, 200),
        b: this.randomInteger(0, 200),
        a: !alpha ? this.random(0.75, 1) : alpha
      };
      return 'rgba(' + colors.r + ', ' + colors.g + ', ' + colors.b + ', ' + colors.a + ')';
    };

    Utils.prototype.randomInteger = function(min, max) {
      if (max === void 0) {
        max = min;
        min = 0;
      }
      return Math.floor(Math.random() * (max + 1 - min)) + min;
    };

    Utils.prototype.randomPercentage = function() {
      return Math.floor(Math.random() * 100);
    };

    Utils.prototype.updateUITextNode = function(element, value) {
      element.innerHTML = value;
      return this;
    };

    return Utils;

  })();

  debug = true;

  android = navigator.userAgent.match(/android/i) ? true : false;

  body = document.body;

  canvas = document.createElement('canvas');

  hasTouchEvents = window.hasOwnProperty('ontouchstart') || window.hasOwnProperty('onmsgesturechange');

  inputVerb = hasTouchEvents ? 'touchstart' : 'click';

  canvas.width = body.clientWidth;

  canvas.height = body.clientHeight;

  body.appendChild(canvas);

  context = canvas.getContext('2d');

  context.globalCompositeOperation = 'source-atop';

  devicePixelRatio = window.devicePixelRatio || 1;

  backingStoreRatio = context.webkitBackingStorePixelRatio || context.backingStorePixelRatio || 1;

  ratio = devicePixelRatio / backingStoreRatio;

  if (devicePixelRatio !== backingStoreRatio) {
    oldWidth = canvas.width;
    oldHeight = canvas.height;
    canvas.width = oldWidth * ratio;
    canvas.height = oldHeight * ratio;
    canvas.style.width = oldWidth + 'px';
    canvas.style.height = oldHeight + 'px';
    context.scale(ratio, ratio);
  }

  animationLoop = new AnimationLoop();

  config = new Config();

  game = new Game();

  input = new Input();

  particleGenerator = new ParticleGenerator();

  utils = new Utils();

  scenes = new Scenes();

  playState = new PlayState();

  ui = new UI();

  game.init();

}).call(this);
