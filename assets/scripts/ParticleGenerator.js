// Generated by CoffeeScript 1.4.0
/*jshint plusplus:false, forin:false
*/

/*global Class
*/

/*global Particle, canvas, context, game
*/

'use strict';

var ParticleGenerator;

ParticleGenerator = Class.extend({
  init: function() {
    var self;
    self = this;
    this.setupParticleOrigin();
    this.particlesArray = [];
    this.particlesArrayIds = [];
    this.particlesToDelete = [];
    this.setupParticleTapDetection();
  },
  requestAnimationFrame: function() {
    var particle, particleId, particleIndex, self, _i, _j, _len, _len1, _ref, _ref1;
    self = this;
    this.animationId = window.requestAnimationFrame(function() {
      self.requestAnimationFrame();
    });
    context.clearRect(0, 0, canvas.width, canvas.height);
    this.generateParticle(1);
    _ref = this.particlesArray;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      context.fillStyle = particle.color;
      context.strokeStyle = particle.color;
      particle.draw();
      particle.updateValues();
    }
    _ref1 = this.particlesToDelete;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      particleId = _ref1[_j];
      particleIndex = this.particlesArrayIds.indexOf(particleId);
      particle = this.particlesArray[particleIndex];
      if (particle.isTarget) {
        this.resetParticleArrays();
        game.gameOver(this.animationId);
      }
      this.removeParticle(particleIndex);
    }
    this.particlesToDelete = [];
  },
  generateParticle: function(count) {
    var newParticle, num, _i;
    for (num = _i = count; count <= 1 ? _i <= 1 : _i >= 1; num = count <= 1 ? ++_i : --_i) {
      newParticle = new Particle();
      if (newParticle.isTarget) {
        this.particlesArray.push(newParticle);
        this.particlesArrayIds.push(newParticle.id);
      } else {
        this.particlesArray.unshift(newParticle);
        this.particlesArrayIds.unshift(newParticle.id);
      }
    }
  },
  removeParticle: function(index) {
    this.particlesArray.splice(index, 1);
    this.particlesArrayIds.splice(index, 1);
  },
  resetParticleArrays: function() {
    this.particlesArray = [];
    this.particlesArrayIds = [];
    this.particlesToDelete = [];
  },
  setupParticleOrigin: function() {
    var self;
    self = this;
    this.particlesOrigin = {
      x: canvas.width / 2,
      y: canvas.height / 2
    };
    document.addEventListener('mousemove', function(event) {
      self.updateParticlesOrigin(event);
    });
    document.addEventListener('touchmove', function(event) {
      self.updateParticlesOrigin(event);
    });
  },
  setupParticleTapDetection: function() {
    var self;
    self = this;
    this.particlesToTestForTaps = [];
    window.addEventListener('touchstart', function(event) {
      var deletionIndex, hitX, hitY, maxX, maxY, minX, minY, particle, particleId, particleIndex, tapX, tapY, _i, _len, _ref;
      tapX = event.touches[0].pageX;
      tapY = event.touches[0].pageY;
      $('.debug .tapX').text(tapX);
      $('.debug .tapY').text(tapY);
      _ref = self.particlesToTestForTaps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particleId = _ref[_i];
        particleIndex = self.particlesArrayIds.indexOf(particleId);
        particle = self.particlesArray[particleIndex];
        minX = particle.position.x - particle.half;
        maxX = minX + particle.size;
        hitX = tapX >= minX && tapX <= maxX;
        minY = particle.position.y - particle.half;
        maxY = minY + particle.size;
        hitY = tapY >= minY && tapY <= maxY;
        if (hitX && hitY) {
          deletionIndex = self.particlesToTestForTaps.indexOf(particleId);
          self.particlesToTestForTaps.splice(deletionIndex, 1);
          self.removeParticle(particleIndex);
        }
      }
    });
  },
  updateParticlesOrigin: function(event) {
    event.preventDefault();
  }
});
