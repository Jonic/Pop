// Generated by CoffeeScript 1.4.0
/*jshint plusplus:false, forin:false, eqeqeq: false
*/

/*global Class, Particle
*/

/*global canvas, context, game, headsUp
*/

'use strict';

var ParticleGenerator;

ParticleGenerator = Class.extend({
  init: function() {
    this.particlesOrigin = {
      x: canvas.width / 2,
      y: canvas.height / 2
    };
    this.particlesArray = [];
    this.particlesArrayIds = [];
    this.particlesToDelete = [];
    this.particlesToTestForTaps = [];
    this.comboMultiplierCounter = $('.combo');
    this.setupParticleTapDetection();
  },
  requestAnimationFrame: function() {
    var particle, particleId, particleIndex, self, _i, _j, _len, _len1, _ref, _ref1;
    self = this;
    this.animationId = window.requestAnimationFrame(function() {
      self.requestAnimationFrame();
    });
    canvas.width = canvas.width;
    this.generateParticle(1);
    _ref = this.particlesArray;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      context.fillStyle = particle.color;
      context.strokeStyle = particle.color;
      particle.draw();
      particle.updateValues();
    }
    _ref1 = this.particlesToDelete;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      particleId = _ref1[_j];
      particleIndex = this.particlesArrayIds.indexOf(particleId);
      particle = this.particlesArray[particleIndex];
      if (particle.isTarget) {
        game.gameOver(this.animationId);
      }
      this.removeParticle(particleIndex);
    }
    this.particlesToDelete = [];
  },
  generateParticle: function(count) {
    var newParticle, num, _i;
    for (num = _i = count; count <= 1 ? _i <= 1 : _i >= 1; num = count <= 1 ? ++_i : --_i) {
      newParticle = new Particle();
      if (newParticle.isTarget) {
        this.particlesArray.push(newParticle);
        this.particlesArrayIds.push(newParticle.id);
      } else {
        this.particlesArray.unshift(newParticle);
        this.particlesArrayIds.unshift(newParticle.id);
      }
    }
  },
  particleWasTapped: function(particle, touchData) {
    var hitX, hitY, maxX, maxY, minX, minY, tapX, tapY;
    tapX = touchData.pageX;
    tapY = touchData.pageY;
    minX = particle.position.x - particle.half;
    maxX = minX + particle.size;
    hitX = tapX >= minX && tapX <= maxX;
    minY = particle.position.y - particle.half;
    maxY = minY + particle.size;
    hitY = tapY >= minY && tapY <= maxY;
    return hitX && hitY;
  },
  reset: function() {},
  removeParticle: function(index) {
    this.particlesArray.splice(index, 1);
    this.particlesArrayIds.splice(index, 1);
  },
  setupParticleTapDetection: function() {
    var self;
    self = this;
    this.particlesToTestForTaps = [];
    window.addEventListener('touchstart', function(event) {
      var deletionIndex, particle, particleId, particleIndex, targetHit, _i, _len, _ref;
      targetHit = false;
      _ref = self.particlesToTestForTaps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particleId = _ref[_i];
        particleIndex = self.particlesArrayIds.indexOf(particleId);
        particle = self.particlesArray[particleIndex];
        if ((particle != null) && self.particleWasTapped(particle, event.touches[0])) {
          deletionIndex = self.particlesToTestForTaps.indexOf(particleId);
          self.particlesToTestForTaps.splice(deletionIndex, 1);
          self.removeParticle(particleIndex);
          targetHit = true;
          break;
        }
      }
      if (targetHit) {
        headsUp.updateScore(particle.size, particle.finalSize);
        headsUp.comboMultiplier += 1;
      } else {
        headsUp.comboMultiplier = 1;
      }
      self.comboMultiplierCounter.text(headsUp.comboMultiplier);
    });
  },
  start: function() {
    this.comboMultiplierCounter.text(headsUp.comboMultiplier);
    this.requestAnimationFrame();
  }
});
