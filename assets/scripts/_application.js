// Generated by CoffeeScript 1.4.0
/*jshint plusplus:false, forin:false, eqeqeq:false
*/

/*global Class, dat
*/

'use strict';

var AnimationLoop, Config, Game, HeadsUp, Input, Particle, ParticleGenerator, Scenes, State, Utils, android, animationLoop, animationLoopId, backingStoreRatio, canvas, config, context, debug, devicePixelRatio, game, headsUp, homeScreenApp, iOS, input, oldHeight, oldWidth, particleGenerator, ratio, scenes, state, utils;

android = navigator.userAgent.match(/android/i) ? true : false;

iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/i) ? true : false;

homeScreenApp = iOS && navigator.standalone;

debug = true;

animationLoopId = null;

canvas = document.createElement('canvas');

context = canvas.getContext('2d');

document.body.appendChild(canvas);

canvas.width = document.width;

canvas.height = document.height;

devicePixelRatio = window.devicePixelRatio || 1;

backingStoreRatio = context.webkitBackingStorePixelRatio || context.backingStorePixelRatio || 1;

ratio = devicePixelRatio / backingStoreRatio;

if (devicePixelRatio !== backingStoreRatio) {
  oldWidth = canvas.width;
  oldHeight = canvas.height;
  canvas.width = oldWidth * ratio;
  canvas.height = oldHeight * ratio;
  canvas.style.width = oldWidth + 'px';
  canvas.style.height = oldHeight + 'px';
  context.scale(ratio, ratio);
}

/* --------------------------------------------
     Begin AnimationLoop.coffee
--------------------------------------------
*/


AnimationLoop = Class.extend({
  init: function() {},
  cancelAnimationFrame: function() {
    window.cancelAnimationFrame(animationLoopId);
  },
  requestAnimationFrame: function() {
    var self;
    self = this;
    animationLoopId = window.requestAnimationFrame(function() {
      self.requestAnimationFrame();
    });
    canvas.width = canvas.width;
    particleGenerator.generateParticle();
    particleGenerator.updateValuesAndDraw();
    particleGenerator.destroyParticlesOutsideCanvasBounds();
  }
});

/* --------------------------------------------
     Begin Config.coffee
--------------------------------------------
*/


Config = Class.extend({
  init: function() {
    this.maxLineWidth = 10;
    this.levelUpInterval = 20;
    this.maxLevel = 50;
    this.pointsPerPop = 10;
    this.particleSpawnChance = {
      easy: 60,
      difficult: 100
    };
    this.chanceParticleIsTarget = {
      easy: 2,
      difficult: 5
    };
    this.particleGrowthMultiplier = {
      easy: 1.05,
      difficult: 1.5
    };
    this.sizeMax = {
      easy: 80,
      difficult: 40
    };
    this.minTargetSize = {
      easy: 80,
      difficult: 30
    };
    this.velocityMin = {
      easy: -5,
      difficult: -15
    };
    this.velocityMax = {
      easy: 5,
      difficult: 15
    };
    this.targetVelocityMultiplier = {
      easy: 0.3,
      difficult: 1
    };
    this.propertiesToUpdateWithDifficulty = ['particleSpawnChance', 'chanceParticleIsTarget', 'particleGrowthMultiplier', 'sizeMax', 'minTargetSize', 'velocityMin', 'velocityMax', 'targetVelocityMultiplier'];
  },
  setupDatGui: function() {
    var environment, gui, size, velocity;
    gui = new dat.GUI();
    environment = gui.addFolder('Environment');
    environment.add(this, 'chanceParticleIsTarget', 0, 100);
    environment.add(this, 'particleSpawnChance', 0, 100);
    environment.add(this, 'maxLineWidth');
    size = gui.addFolder('Size');
    size.add(this, 'minTargetSize', 40);
    size.add(this, 'sizeMin', 0);
    size.add(this, 'sizeMax', 70);
    velocity = gui.addFolder('Velocity');
    velocity.add(this, 'targetVelocityMultiplier', 0.3);
    velocity.add(this, 'velocityMin', -5);
    velocity.add(this, 'velocityMax', 5);
  },
  updateValuesForDifficulty: function() {
    var levelMulitplier, property, propertyConfig, valueDifference, _i, _len, _ref;
    _ref = this.propertiesToUpdateWithDifficulty;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      propertyConfig = this[property];
      valueDifference = propertyConfig.difficult - propertyConfig.easy;
      levelMulitplier = state.level / this.maxLevel;
      state[property] = (valueDifference * levelMulitplier) + propertyConfig.easy;
    }
  }
});

/* --------------------------------------------
     Begin Game.coffee
--------------------------------------------
*/


Game = Class.extend({
  init: function() {},
  run: function() {
    animationLoop.requestAnimationFrame();
    this.reset();
    scenes.title();
  },
  reset: function() {
    state.reset();
    headsUp.reset();
    particleGenerator.reset();
  },
  start: function() {
    state.setupLevelUpIncrement();
    particleGenerator.start();
  }
});

/* --------------------------------------------
     Begin HeadsUp.coffee
--------------------------------------------
*/


HeadsUp = Class.extend({
  init: function() {
    this.levelCounter = '.level';
    this.scoreCounter = '.score';
    this.comboMultiplierCounter = '.combo';
    this.tapX = '.tapX';
    this.tapY = '.tapY';
  },
  reset: function() {
    this.updateComboMultiplierCounter();
    this.updateLevelCounter();
    this.updateScoreCounter();
  },
  updateComboMultiplierCounter: function() {
    utils.updateUITextNode(this.comboMultiplierCounter, state.comboMultiplier);
  },
  updateLevelCounter: function() {
    utils.updateUITextNode(this.levelCounter, state.level);
  },
  updateScoreCounter: function() {
    utils.updateUITextNode(this.scoreCounter, state.score);
  }
});

/* --------------------------------------------
     Begin Input.coffee
--------------------------------------------
*/


Input = Class.extend({
  init: function() {
    window.addEventListener('touchmove', function(event) {
      return event.preventDefault();
    });
  }
});

/* --------------------------------------------
     Begin Particle.coffee
--------------------------------------------
*/


Particle = Class.extend({
  init: function() {
    var colors, self;
    self = this;
    colors = {
      r: utils.randomInteger(0, 200),
      g: utils.randomInteger(0, 200),
      b: utils.randomInteger(0, 200),
      a: utils.random(0.9, 1)
    };
    this.color = 'rgba(' + colors.r + ', ' + colors.g + ', ' + colors.b + ', ' + colors.a + ')';
    this.size = 1;
    this.finalSize = utils.randomInteger(0, state.sizeMax);
    this.half = Math.round(this.size / 2);
    this.position = {
      x: particleGenerator.particlesOrigin.x,
      y: particleGenerator.particlesOrigin.y
    };
    this.velocity = {
      x: utils.random(state.velocityMin, state.velocityMax),
      y: utils.random(state.velocityMin, state.velocityMax)
    };
    this.id = Math.random().toString(36).substr(2, 5);
    this.isTarget = this.determineTargetParticle();
    if (this.isTarget) {
      this.finalSize = utils.randomInteger(state.minTargetSize, state.sizeMax);
      this.color = 'rgba(' + colors.r + ', ' + colors.g + ', ' + colors.b + ', 1)';
      this.velocity.x = this.velocity.x * state.targetVelocityMultiplier;
      this.velocity.y = this.velocity.y * state.targetVelocityMultiplier;
      this.lineWidth = 1;
      particleGenerator.particlesToTestForTaps.push(this.id);
    }
  },
  determineTargetParticle: function() {
    return utils.randomPercentage() < state.chanceParticleIsTarget;
  },
  draw: function() {
    if (this.withinCanvasBounds()) {
      context.beginPath();
      context.arc(this.position.x, this.position.y, this.half, 0, Math.PI * 2, true);
      if (this.isTarget) {
        context.fillStyle = 'rgb(255, 255, 255)';
        context.lineWidth = this.lineWidth;
        context.stroke();
        if (this.lineWidth < config.maxLineWidth) {
          this.lineWidth = this.lineWidth * 1.1;
        } else if (this.lineWidth > config.maxLineWidth) {
          this.lineWidth = config.maxLineWidth;
        }
      }
      context.fill();
      context.closePath();
    } else {
      particleGenerator.particlesToDelete.push(this.id);
    }
  },
  updateValues: function() {
    if (this.size < this.finalSize) {
      this.size = this.size * state.particleGrowthMultiplier;
    }
    if (this.size > this.finalSize) {
      this.size = this.finalSize;
    }
    this.half = Math.round(this.size / 2);
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;
  },
  withinCanvasBounds: function() {
    var beyondBoundsX, beyondBoundsY;
    beyondBoundsX = this.position.x < -this.size || this.position.x > canvas.width + this.size;
    beyondBoundsY = this.position.y < -this.size || this.position.y > canvas.height + this.size;
    return !(beyondBoundsX || beyondBoundsY);
  }
});

/* --------------------------------------------
     Begin ParticleGenerator.coffee
--------------------------------------------
*/


ParticleGenerator = Class.extend({
  init: function() {
    this.particlesOrigin = {
      x: canvas.width / 2,
      y: canvas.height / 2
    };
    this.reset();
    this.setupParticleTapDetection();
  },
  destroyParticlesOutsideCanvasBounds: function() {
    var particle, particleId, particleIndex, _i, _len, _ref;
    _ref = this.particlesToDelete;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particleId = _ref[_i];
      particleIndex = this.particlesArrayIds.indexOf(particleId);
      particle = this.particlesArray[particleIndex];
      if (particle.isTarget) {
        scenes.gameOver();
      }
      this.removeParticle(particleIndex);
    }
    this.particlesToDelete = [];
  },
  generateParticle: function() {
    var newParticle;
    if (utils.randomPercentage() < state.particleSpawnChance) {
      newParticle = new Particle();
      this.particlesArray.push(newParticle);
      this.particlesArrayIds.push(newParticle.id);
    }
  },
  particleTapDetectionHandler: function() {
    var deletionIndex, particle, particleId, particleIndex, targetHit, touchData, _i, _len, _ref;
    targetHit = false;
    _ref = this.particlesToTestForTaps.reverse();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particleId = _ref[_i];
      particleIndex = this.particlesArrayIds.indexOf(particleId);
      particle = this.particlesArray[particleIndex];
      touchData = event.touches[0];
      if ((particle != null) && this.particleWasTapped(particle, touchData)) {
        deletionIndex = this.particlesToTestForTaps.indexOf(particleId);
        this.particlesToTestForTaps.splice(deletionIndex, 1);
        this.removeParticle(particleIndex);
        targetHit = true;
        break;
      }
    }
    state.updateComboMultiplier(targetHit);
    if (targetHit) {
      state.updateScore(particle.size, particle.finalSize);
    }
  },
  particleWasTapped: function(particle, touchData) {
    var hitX, hitY, maxX, maxY, minX, minY, tapX, tapY;
    tapX = touchData.pageX * devicePixelRatio;
    tapY = touchData.pageY * devicePixelRatio;
    minX = particle.position.x - particle.half;
    maxX = minX + particle.size;
    hitX = tapX >= minX && tapX <= maxX;
    minY = particle.position.y - particle.half;
    maxY = minY + particle.size;
    hitY = tapY >= minY && tapY <= maxY;
    return hitX && hitY;
  },
  removeParticle: function(index) {
    this.particlesArray.splice(index, 1);
    this.particlesArrayIds.splice(index, 1);
  },
  reset: function() {
    this.particlesArray = [];
    this.particlesArrayIds = [];
    this.particlesToDelete = [];
    this.particlesToTestForTaps = [];
  },
  setupParticleTapDetection: function() {
    var self;
    self = this;
    this.particlesToTestForTaps = [];
    window.addEventListener('touchstart', function() {
      self.particleTapDetectionHandler();
    });
  },
  start: function() {
    state.updateGameState('playing');
  },
  updateValuesAndDraw: function() {
    var particle, _i, _len, _ref;
    _ref = this.particlesArray;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      particle = _ref[_i];
      context.fillStyle = particle.color;
      context.strokeStyle = particle.color;
      particle.draw();
      particle.updateValues();
    }
  }
});

/* --------------------------------------------
     Begin Scenes.coffee
--------------------------------------------
*/


Scenes = Class.extend({
  init: function() {
    this.splash();
  },
  credits: function() {},
  gameOver: function() {
    alert('GAME OVER');
    animationLoop.cancelAnimationFrame();
    game.reset();
  },
  howToPlay: function() {},
  installationPrompt: function() {
    utils.updateUITextNode('body', 'ADD THIS TO YOUR HOME SCREEN TO PLAY');
  },
  mobilePrompt: function() {
    utils.updateUITextNode('body', 'YOU NEED TO RUN THIS ON A MOBILE DEVICE');
  },
  splash: function() {},
  title: function() {
    game.start();
  }
});

/* --------------------------------------------
     Begin State.coffee
--------------------------------------------
*/


State = Class.extend({
  init: function() {
    this.defaults = {
      level: 1,
      score: 0,
      comboMultiplier: 0
    };
  },
  setup: function() {
    this.reset();
  },
  setupLevelUpIncrement: function() {
    var self;
    self = this;
    this.levelUpCounter = window.setInterval(function() {
      self.updateLevel();
    }, config.levelUpInterval * 1000);
  },
  reset: function() {
    window.clearInterval(this.levelUpCounter);
    this.level = this.defaults.level;
    this.score = this.defaults.score;
    this.comboMultiplier = this.defaults.comboMultiplier;
    this.particleSpawnChance = config.particleSpawnChance.easy;
    this.chanceParticleIsTarget = config.chanceParticleIsTarget.easy;
    this.particleGrowthMultiplier = config.particleGrowthMultiplier.easy;
    this.sizeMax = config.sizeMax.easy;
    this.minTargetSize = config.minTargetSize.easy;
    this.velocityMin = config.velocityMin.easy;
    this.velocityMax = config.velocityMax.easy;
    this.targetVelocityMultiplier = config.targetVelocityMultiplier.easy;
  },
  updateComboMultiplier: function(targetHit) {
    state.comboMultiplier = targetHit ? state.comboMultiplier + 1 : 1;
    headsUp.updateComboMultiplierCounter();
  },
  updateGameState: function(newState) {
    this.gameState = newState;
  },
  updateLevel: function() {
    this.level += 1;
    if (this.level >= config.maxLevel) {
      window.clearInterval(this.levelUpCounter);
    }
    headsUp.updateLevelCounter();
    config.updateValuesForDifficulty();
  },
  updateScore: function(sizeWhenTapped, sizeWhenFullyGrown) {
    var levelMultiplier, popPointValue, targetSizeBonus;
    targetSizeBonus = Math.round(100 - ((sizeWhenTapped / sizeWhenFullyGrown) * 100));
    popPointValue = config.pointsPerPop + targetSizeBonus;
    levelMultiplier = this.level + 1;
    this.score += (popPointValue * this.comboMultiplier) * levelMultiplier;
    headsUp.updateScoreCounter();
  }
});

/* --------------------------------------------
     Begin Utils.coffee
--------------------------------------------
*/


Utils = Class.extend({
  init: function() {},
  correctValueForDPR: function(value, int) {
    if (int == null) {
      int = false;
    }
    if (int) {
      return Math.round(value * devicePixelRatio);
    } else {
      return value * devicePixelRatio;
    }
  },
  random: function(min, max) {
    if (min === void 0) {
      min = 0;
      max = 1;
    } else if (max === void 0) {
      max = min;
      min = 0;
    }
    return (Math.random() * (max - min)) + min;
  },
  randomInteger: function(min, max) {
    if (max === void 0) {
      max = min;
      min = 0;
    }
    return Math.floor(Math.random() * (max + 1 - min)) + min;
  },
  randomPercentage: function() {
    return Math.floor(Math.random() * 101);
  },
  updateUITextNode: function(selector, value) {
    var element;
    element = document.querySelector(selector);
    element.innerHTML = value;
  }
});

/* --------------------------------------------
     Begin _bootstrap.coffee
--------------------------------------------
*/


animationLoop = new AnimationLoop();

config = new Config();

game = new Game();

headsUp = new HeadsUp();

input = new Input();

particleGenerator = new ParticleGenerator();

utils = new Utils();

scenes = new Scenes();

state = new State();

if (android || homeScreenApp || debug) {
  game.run();
} else if (iOS) {
  scenes.installationPrompt();
} else {
  scenes.mobilePrompt();
}
