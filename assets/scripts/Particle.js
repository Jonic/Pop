// Generated by CoffeeScript 1.4.0
/*jshint plusplus:false, forin:false
*/

/*global Class
*/

/*global game, random, randomInteger
*/

'use strict';

var Particle;

Particle = Class.extend({
  init: function() {
    var self;
    self = this;
    this.id = Math.random().toString(36).substr(2, 5);
    this.colors = {
      r: randomInteger(0, 255),
      g: randomInteger(0, 255),
      b: randomInteger(0, 255)
    };
    this.color = 'rgb(' + this.colors.r + ', ' + this.colors.g + ', ' + this.colors.b + ')';
    this.size = parseInt(1, 10);
    this.finalSize = randomInteger(0, 70);
    this.half = Math.round(this.size / 2);
    this.isTarget = false;
    if (this.finalSize > 40) {
      this.isTarget = this.determineTargetParticle();
    }
    this.position = {
      x: particleGenerator.particlesOrigin.x,
      y: particleGenerator.particlesOrigin.y
    };
    this.velocity = {
      x: random(-5, 5),
      y: random(-5, 5)
    };
    if (this.isTarget) {
      this.velocity.x = this.velocity.x * 0.3;
      this.velocity.y = this.velocity.y * 0.3;
      particleGenerator.particlesToTestForTaps.push(this.id);
    }
  },
  determineTargetParticle: function() {
    return Math.floor(Math.random() * 101) < 5;
  },
  draw: function() {
    if (this.withinCanvasBounds()) {
      context.beginPath();
      context.arc(this.position.x, this.position.y, this.half, 0, Math.PI * 2, true);
      if (this.isTarget) {
        context.fillStyle = 'rgb(255, 255, 255)';
        context.lineWidth = 10;
        context.stroke();
      }
      context.fill();
      context.closePath();
    } else {
      particleGenerator.particlesToDelete.push(this.id);
    }
  },
  updateValues: function() {
    if (this.size < this.finalSize) {
      this.size = this.size * 1.05;
    }
    if (this.size > this.finalSize) {
      this.size = this.finalSize;
    }
    this.half = Math.round(this.size / 2);
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;
  },
  withinCanvasBounds: function() {
    var beyondBoundsX, beyondBoundsY;
    beyondBoundsX = this.position.x < -this.size || this.position.x > canvas.width + this.size;
    beyondBoundsY = this.position.y < -this.size || this.position.y > canvas.height + this.size;
    return !(beyondBoundsX || beyondBoundsY);
  }
});
